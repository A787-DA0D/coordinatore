# main.py
from fastapi import FastAPI, Request, Header, HTTPException, Query
from fastapi.responses import PlainTextResponse
from pydantic import BaseModel, Field
from typing import Optional, Any, Dict
import os
import logging
import json
from datetime import datetime, timezone
import uuid

from sqlalchemy import (
    create_engine,
    text,
    MetaData,
    Table,
    Column,
    String,
    Integer,
    Float,
    DateTime,
    Boolean,
    ForeignKey,
)
from sqlalchemy.dialects.postgresql import UUID as PG_UUID

import httpx
import urllib.request

from google.cloud import tasks_v2  # ancora usato solo per vecchio /tick (ora disabilitato)

import router_cefi as executor  # CeFi router (governor + forward)


# ======================
# CONFIG DB & FASTAPI
# ======================

app = FastAPI(title="Cerbero Coordinator v2")


def _project_id():
    return (
        os.getenv("GOOGLE_CLOUD_PROJECT")
        or os.getenv("GCP_PROJECT")
        or os.getenv("PROJECT_ID")
        or os.getenv("COSCIENZA_PROJECT_ID")
    )


SQL_USER = os.getenv("SQL_DB_USER")
SQL_PASS = os.getenv("SQL_DB_PASS") or os.getenv("DB_PASSWORD")
SQL_NAME = os.getenv("SQL_DB_NAME")
SQL_HOST = os.getenv("SQL_DB_HOST")  # es: 34.154.xx.xx

if not (SQL_USER and SQL_PASS and SQL_NAME and SQL_HOST):
    logging.warning("DB env incomplete, some DB endpoints may fail")
    engine = None
else:
    DB_URL = f"postgresql+psycopg://{SQL_USER}:{SQL_PASS}@{SQL_HOST}/{SQL_NAME}"
    engine = create_engine(DB_URL, pool_pre_ping=True)

metadata = MetaData()

tenants = Table(
    "tenants",
    metadata,
    Column("id", PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
    Column("email", String(255), nullable=False, unique=True),
    Column("stripe_customer_id", String(255)),
    Column(
        "created_at",
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    ),
)

contracts = Table(
    "contracts",
    metadata,
    Column("id", PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
    Column("tenant_id", PG_UUID(as_uuid=True), ForeignKey("tenants.id"), nullable=False),
    Column("arbitrum_address", String(64), nullable=False),
    Column("status", String(32), nullable=False, default="inactive"),
    Column("deposit_cap_eur", Integer, nullable=False, default=999),
    Column(
        "created_at",
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    ),
)

signals = Table(
    "signals",
    metadata,
    Column("id", PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
    Column("symbol", String(16), nullable=False),
    Column("score", Float, nullable=False),
    Column("p", Float, nullable=False),
    Column("e", Float, nullable=False),
    Column("r", Float, nullable=False),
    Column("v", Float, nullable=False),
    Column(
        "created_at",
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    ),
)

jobs = Table(
    "jobs",
    metadata,
    Column("id", PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
    Column("tenant_id", PG_UUID(as_uuid=True), ForeignKey("tenants.id"), nullable=False),
    Column("signal_id", PG_UUID(as_uuid=True), ForeignKey("signals.id")),
    Column("status", String(32), nullable=False, default="pending"),
    Column(
        "created_at",
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    ),
)

PYTH_HERMES_URL = os.getenv("PYTH_HERMES_URL", "https://hermes.pyth.network")
ADMIN_SEED_KEY = os.getenv("ADMIN_SEED_KEY", "")

COORD_API_KEY = os.getenv("COORDINATOR_API_KEY", "")  # usata per X-API-Key


# ======================
# MODELLI Pydantic
# ======================

class TradeIntentMeta(BaseModel):
    source: Optional[str] = None
    model_version: Optional[str] = None
    mtf_status: Optional[str] = None
    context_ok: Optional[bool] = None


class TradeIntentIn(BaseModel):
    symbol: str = Field(..., description="ES: EURUSD, XAUUSD, BTCUSD")
    timeframe: str = Field(..., description="ES: 5m, 15m, 4h, 1d")
    direction: str = Field(..., pattern="^(LONG|SHORT)$")
    strength_class: str = Field(..., description="Es: A, A_PLUS")
    risk_pct: float = Field(..., gt=0, description="Es: 0.008 per 0.8%")
    ts_signal: str = Field(..., description="ISO8601 UTC timestamp")
    user_id: Optional[str] = Field("TEST_USER_001", description="ID utente/tenant")
    meta: Optional[TradeIntentMeta] = None


# ======================
# ENDPOINT DI BASE
# ======================

@app.get("/healthz", response_class=PlainTextResponse)
def healthz():
    return "ok"


@app.get("/dbtest")
def dbtest():
    """Test rapido connessione DB globale."""
    if engine is None:
        raise HTTPException(status_code=500, detail="engine not initialized (DB env missing)")

    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT 1")).scalar()
        return {"db": result}
    except Exception as e:
        logging.exception("dbtest failed")
        raise HTTPException(status_code=500, detail=f"db error: {e}")


@app.post("/migrate", response_class=PlainTextResponse)
def migrate():
    if engine is None:
        raise HTTPException(status_code=500, detail="engine not initialized")
    metadata.create_all(engine)
    return "migrated"


@app.post("/worker", response_class=PlainTextResponse)
def worker():
    # placeholder: in futuro processeremo il job (trade singolo utente) in modo async
    return "worker-ack"


# ======================
# MOCK /tick (disabilitato, ma lasciato per retrocompatibilit√†)
# ======================

@app.post("/tick", response_class=PlainTextResponse)
async def tick():
    try:
        PROJECT = _project_id()
        if not PROJECT:
            raise RuntimeError("Missing project id env")

        # Non usiamo pi√π Cloud Tasks per questo; la Coscienza v3 parler√† con /v1/trade-intent.
        return "tick-disabled: use /v1/trade-intent from Coscienza v3"
    except Exception as e:
        logging.exception("tick failed")
        return PlainTextResponse(f"tick-error: {e}", status_code=500)


# ======================
# ARBI BLOCK (gi√† usato)
# ======================

@app.get("/arbi/block")
def arbi_block():
    url = os.environ.get("ALCHEMY_HTTP_ARBITRUM") or os.environ.get("ARBITRUM_RPC_URL")
    if not url:
        raise HTTPException(
            status_code=500,
            detail="ALCHEMY_HTTP_ARBITRUM/ARBITRUM_RPC_URL not set",
        )
    body = {"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber", "params": []}
    req = urllib.request.Request(
        url,
        data=json.dumps(body).encode("utf-8"),
        headers={"content-type": "application/json"},
        method="POST",
    )
    with urllib.request.urlopen(req, timeout=10) as r:
        payload = json.loads(r.read().decode())
    res = payload.get("result")
    height = int(res, 16) if isinstance(res, str) else None
    return {"ok": True, "height": height, "result": res}


# ======================
# PYTH PRICE HELPER (ancora esposto)
# ======================

@app.get("/pyth/price")
async def pyth_price(id: str = Query(..., description="Pyth price feed id (0x...)")):
    """Chiama Hermes con un singolo feed id e ritorna il last price."""
    try:
        url_base = (
            globals().get("PYTH_HERMES_URL")
            or os.environ.get("PYTH_HERMES_URL")
            or "https://hermes.pyth.network"
        )
        if not id.startswith("0x") or len(id) < 10:
            raise HTTPException(status_code=400, detail="invalid feed id")
        url = url_base.rstrip("/") + "/api/latest_price_feeds"
        params = {"ids[]": [id]}
        async with httpx.AsyncClient(timeout=5.0) as client:
            r = await client.get(url, params=params)
            r.raise_for_status()
            data = r.json()
        if not data:
            return {"ok": False, "id": id, "reason": "not found"}
        item = data[0]
        price = item.get("price", {})
        px, expo = price.get("price"), price.get("expo", 0)
        out = float(px) * (10 ** float(expo)) if px is not None else None
        return {"ok": True, "id": id, "price": out, "raw": item}
    except httpx.HTTPError as e:
        logging.exception("hermes http error")
        raise HTTPException(status_code=502, detail=f"hermes error: {e}") from e
    except Exception as e:
        logging.exception("pyth_price failed")
        raise HTTPException(status_code=500, detail=f"internal error: {e}") from e


# ======================
# üî• /v1/trade-intent ‚Äì cuore dell‚Äôautotrader
# ======================

@app.post("/v1/trade-intent")
async def v1_trade_intent(
    intent: TradeIntentIn,
    x_api_key: Optional[str] = Header(None),
):
    # DEBUG: vedere cosa arriva davvero
    logging.info("X-API-Key header received: %r", x_api_key)

    # 1) AUTH
    if COORD_API_KEY:
        if not x_api_key or x_api_key != COORD_API_KEY:
            logging.error(
                "API KEY MISMATCH: header=%r expected=%r",
                x_api_key,
                COORD_API_KEY,
            )
            raise HTTPException(status_code=401, detail="invalid api key")

    # 2) Validazione simbolo
    symbol = intent.symbol.upper()
    if symbol not in executor.COSCIENZA_SYMBOLS_V3:
        raise HTTPException(
            status_code=400,
            detail=f"symbol {symbol} not in allowed universe",
        )

    if engine is None:
        raise HTTPException(status_code=500, detail="engine not initialized")

    # 3) Serializza intent in dict ‚Äúpiatto‚Äù
    intent_dict: Dict[str, Any] = intent.model_dump()
    intent_dict["symbol"] = symbol

    try:
        result = await executor.process_trade_intent(engine, intent_dict)
        return result
    except Exception as e:
        logging.exception("process_trade_intent failed")
        return {
            "intent_id": None,
            "status": "ERROR",
            "message": str(e),
        }


# ============================
# ADMIN ENDPOINT - SEED TEST USER
# ============================

@app.post("/admin/seed-test-user")
def admin_seed_test_user(
    x_admin_seed_key: str = Header(default=""),  # X-Admin-Seed-Key
):
    """
    Endpoint admin per creare/assicurare TEST_USER_001 nel DB,
    associato al wallet TEST_USER_WALLET.
    Protetto da header:
      X-Admin-Seed-Key: <ADMIN_SEED_KEY>
    """
    from executor import ensure_test_user

    # 1) Controllo chiave admin
    admin_key = os.getenv("ADMIN_SEED_KEY", "")
    if not admin_key:
        raise HTTPException(
            status_code=500,
            detail="ADMIN_SEED_KEY not configured",
        )

    if x_admin_seed_key != admin_key:
        raise HTTPException(status_code=401, detail="invalid admin key")

    # 2) Controllo engine
    if engine is None:
        raise HTTPException(status_code=500, detail="engine not initialized")

    # 3) Wallet di test
    test_wallet = os.getenv("TEST_USER_WALLET") or os.getenv("RELAYER_ADDRESS")
    if not test_wallet:
        raise HTTPException(
            status_code=500,
            detail="TEST_USER_WALLET or RELAYER_ADDRESS missing",
        )

    # 4) Creo/assicuro utente di test
    ensure_test_user(engine, "TEST_USER_001", test_wallet)

    return {
        "ok": True,
        "user_id": "TEST_USER_001",
        "wallet": test_wallet,
    }


# ============ DEBUG ADMIN SEED ============

@app.post("/admin/seed-test-user-debug", response_class=PlainTextResponse)
async def admin_seed_test_user_debug(request: Request):
    from executor import ensure_test_user

    admin_key = os.getenv("ADMIN_SEED_KEY", "")
    if not admin_key:
        return PlainTextResponse(
            "admin-error: ADMIN_SEED_KEY not configured",
            status_code=500,
        )

    hdr = request.headers.get("X-Admin-Seed-Key")
    if hdr != admin_key:
        return PlainTextResponse(
            f"admin-error: bad key hdr={hdr!r}",
            status_code=401,
        )

    if engine is None:
        return PlainTextResponse(
            "admin-error: engine not initialized",
            status_code=500,
        )

    test_wallet = os.getenv("TEST_USER_WALLET") or os.getenv("RELAYER_ADDRESS")
    if not test_wallet:
        return PlainTextResponse(
            "admin-error: TEST_USER_WALLET/RELAYER_ADDRESS missing",
            status_code=500,
        )

    try:
        ensure_test_user(engine, "TEST_USER_001", test_wallet)
        return PlainTextResponse(
            f"seed-ok TEST_USER_001 {test_wallet}",
            status_code=200,
        )
    except Exception as e:
        logging.exception("admin seed debug failed")
        return PlainTextResponse(
            f"admin-error exception: {e}",
            status_code=500,
        )
